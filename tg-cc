#!/usr/bin/env python3
import argparse
import logging
import subprocess
import os
import yaml
import uuid
from datetime import datetime
from telegram import Update
from telegram.ext import Application, MessageHandler, CommandHandler, filters, ContextTypes

# Ensure ~/.local/bin is in PATH for commands like claude-monitor
user_local_bin = os.path.expanduser("~/.local/bin")
if user_local_bin not in os.environ.get("PATH", ""):
    os.environ["PATH"] = f"{user_local_bin}:{os.environ.get('PATH', '')}"

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

AUTHORIZED_USERS = []
AUTHORIZED_GROUPS = []
PROJECTS = []
ASK_RULES = ""
FEAT_RULES = ""
FIX_RULES = ""
FEEDBACK_RULES = ""

def load_config():
    """Load configuration from config.yaml"""
    global PROJECTS, AUTHORIZED_USERS, AUTHORIZED_GROUPS, ASK_RULES, FEAT_RULES, FIX_RULES, FEEDBACK_RULES
    try:
        config_file = os.path.join(os.path.dirname(__file__), "config.yaml")
        with open(config_file, 'r') as f:
            data = yaml.safe_load(f)

            PROJECTS = data.get('projects', [])
            AUTHORIZED_USERS = data.get('authorized_users', [])
            AUTHORIZED_GROUPS = data.get('authorized_groups', [])
            ASK_RULES = data.get('ask_rules', '')
            FEAT_RULES = data.get('feat_rules', '')
            FIX_RULES = data.get('fix_rules', '')
            FEEDBACK_RULES = data.get('feedback_rules', '')

            logger.info(f"Loaded {len(PROJECTS)} projects from config.yaml")
            for project in PROJECTS:
                logger.info(f"  - {project['project_name']}: {project['project_workdir']}")

            logger.info(f"Loaded {len(AUTHORIZED_USERS)} authorized users")
            for user in AUTHORIZED_USERS:
                logger.info(f"  - {user}")

            logger.info(f"Loaded {len(AUTHORIZED_GROUPS)} authorized groups")
            for group in AUTHORIZED_GROUPS:
                logger.info(f"  - {group}")

    except Exception as e:
        logger.error(f"Error loading config.yaml: {e}")
        PROJECTS = []
        AUTHORIZED_USERS = []
        AUTHORIZED_GROUPS = []

def is_authorized(update: Update) -> bool:
    """Check if the user and chat are authorized to use the bot."""
    if not update.message or not update.message.from_user:
        return False

    username = update.message.from_user.username
    chat_id = str(update.message.chat.id)

    logger.info(f"Checking authorization for user: {username}, chat_id: {chat_id}")

    user_authorized = username in AUTHORIZED_USERS
    group_authorized = chat_id in AUTHORIZED_GROUPS

    return user_authorized and group_authorized

async def run_claude_command(cmd, cwd, request_uuid):
    """Execute Claude command and return result with timing."""
    start_time = datetime.now()

    result = subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=True,
        text=True,
        timeout=1800
    )

    end_time = datetime.now()
    duration_minutes = (end_time - start_time).total_seconds() / 60

    logger.info(f"Command stdout: {result.stdout}")
    logger.info(f"Command stderr: {result.stderr}")
    logger.info(f"Return code: {result.returncode}")
    logger.info(f"Duration: {duration_minutes:.2f} minutes")

    return result, duration_minutes

async def process_output_file(update, output_file, duration_minutes):
    """Process output file and send to user with cleanup."""
    if os.path.exists(output_file):
        with open(output_file, 'a') as f:
            f.write(f"\n\nExecution time: {duration_minutes:.2f} minutes")

    if os.path.exists(output_file):
        with open(output_file, 'r') as f:
            output_content = f.read()

        if output_content:
            if len(output_content) > 4000:
                await update.message.reply_text(output_content[:4000] + "\n\n[Output truncated...]")
            else:
                await update.message.reply_text(output_content)
        else:
            await update.message.reply_text(f"Command completed but {output_file} is empty")

        os.remove(output_file)
        logger.info(f"Cleaned up {output_file}")
    else:
        await update.message.reply_text(f"Error: {output_file} was not created by Claude")

def cleanup_output_file(output_file):
    """Clean up output file if it exists."""
    if os.path.exists(output_file):
        os.remove(output_file)
        logger.info(f"Cleaned up {output_file}")

async def clone_repository_if_needed(update, project_repo, project_workdir):
    """Clone repository if project directory doesn't exist."""
    if not os.path.exists(project_workdir):
        await update.message.reply_text(f"Project directory not found. Cloning {project_repo}...")
        logger.info(f"Cloning {project_repo} into {project_workdir}")

        try:
            parent_dir = os.path.dirname(project_workdir)
            if parent_dir and not os.path.exists(parent_dir):
                os.makedirs(parent_dir, exist_ok=True)

            clone_result = subprocess.run(
                ["git", "clone", project_repo, project_workdir],
                capture_output=True,
                text=True,
                timeout=1800
            )

            if clone_result.returncode != 0:
                await update.message.reply_text(f"Failed to clone repository:\n{clone_result.stderr[:500]}")
                return False

            await update.message.reply_text(f"Repository cloned successfully!")
            logger.info(f"Successfully cloned {project_repo}")
            return True

        except subprocess.TimeoutExpired:
            await update.message.reply_text("Git clone timed out after 30 minutes")
            return False
        except Exception as e:
            logger.error(f"Error cloning repository: {e}")
            await update.message.reply_text(f"Error cloning repository: {str(e)}")
            return False

    return True

async def refresh_to_main_branch(update, project_workdir):
    """Check if CLAUDE.md exists, if not run claude /init to create it, then commit and push."""
    claude_md_path = os.path.join(project_workdir, "CLAUDE.md")

    logger.info(f"Preparing fresh main branch")

    try:
        # Clean up the branch - reset any uncommitted changes
        logger.info("Cleaning up branch")

        reset_result = subprocess.run(
            ["git", "reset", "--hard"],
            cwd=project_workdir,
            capture_output=True,
            text=True,
            timeout=60
        )

        if reset_result.returncode != 0:
            logger.error(f"git reset failed: {reset_result.stderr}")
            await update.message.reply_text(f"Warning: Could not clean branch:\n{reset_result.stderr[:500]}")

        # Clean untracked files
        clean_result = subprocess.run(
            ["git", "clean", "-fd"],
            cwd=project_workdir,
            capture_output=True,
            text=True,
            timeout=60
        )

        if clean_result.returncode != 0:
            logger.error(f"git clean failed: {clean_result.stderr}")

        # Checkout to main branch
        logger.info("Checking out main branch")

        checkout_result = subprocess.run(
            ["git", "checkout", "main"],
            cwd=project_workdir,
            capture_output=True,
            text=True,
            timeout=60
        )

        if checkout_result.returncode != 0:
            logger.error(f"git checkout main failed: {checkout_result.stderr}")
            await update.message.reply_text(f"Warning: Could not checkout main:\n{checkout_result.stderr[:500]}")

        # Pull latest from main
        logger.info("Pulling from origin/main")

        pull_result = subprocess.run(
            ["git", "pull", "origin", "main"],
            cwd=project_workdir,
            capture_output=True,
            text=True,
            timeout=300
        )

        if pull_result.returncode != 0:
            logger.error(f"git pull failed: {pull_result.stderr}")
            await update.message.reply_text(f"Warning: Could not pull from main:\n{pull_result.stderr[:500]}")

        return True

    except Exception as e:
        logger.error(f"Error refreshing to main branch")
        await update.message.reply_text(f"Error refreshing to main branch: {str(e)}")
        return False

async def initialize_claude_md_if_needed(update, project_workdir):
    """Check if CLAUDE.md exists, if not run claude /init to create it, then commit and push."""
    claude_md_path = os.path.join(project_workdir, "CLAUDE.md")

    if os.path.exists(claude_md_path):
        logger.info(f"CLAUDE.md already exists in {project_workdir}")
        return True

    await update.message.reply_text("CLAUDE.md not found. Preparing to initialize codebase...")
    logger.info(f"Preparing to run claude /init in {project_workdir}")

    try:
        # Clean up the branch - reset any uncommitted changes
        logger.info("Cleaning up branch")

        reset_result = subprocess.run(
            ["git", "reset", "--hard"],
            cwd=project_workdir,
            capture_output=True,
            text=True,
            timeout=60
        )

        if reset_result.returncode != 0:
            logger.error(f"git reset failed: {reset_result.stderr}")
            await update.message.reply_text(f"Warning: Could not clean branch:\n{reset_result.stderr[:500]}")

        # Clean untracked files
        clean_result = subprocess.run(
            ["git", "clean", "-fd"],
            cwd=project_workdir,
            capture_output=True,
            text=True,
            timeout=60
        )

        if clean_result.returncode != 0:
            logger.error(f"git clean failed: {clean_result.stderr}")

        # Checkout to main branch
        logger.info("Checking out main branch")

        checkout_result = subprocess.run(
            ["git", "checkout", "main"],
            cwd=project_workdir,
            capture_output=True,
            text=True,
            timeout=60
        )

        if checkout_result.returncode != 0:
            logger.error(f"git checkout main failed: {checkout_result.stderr}")
            await update.message.reply_text(f"Warning: Could not checkout main:\n{checkout_result.stderr[:500]}")

        # Pull latest from main
        logger.info("Pulling from origin/main")

        pull_result = subprocess.run(
            ["git", "pull", "origin", "main"],
            cwd=project_workdir,
            capture_output=True,
            text=True,
            timeout=300
        )

        if pull_result.returncode != 0:
            logger.error(f"git pull failed: {pull_result.stderr}")
            await update.message.reply_text(f"Warning: Could not pull from main:\n{pull_result.stderr[:500]}")

        # Now run claude /init
        await update.message.reply_text("Running claude /init to generate CLAUDE.md...")
        logger.info(f"Running claude /init in {project_workdir}")

        init_result = subprocess.run(
            ["claude", "/init", "--dangerously-skip-permissions"],
            cwd=project_workdir,
            capture_output=True,
            text=True,
            timeout=1800
        )

        if init_result.returncode != 0:
            logger.error(f"claude /init failed: {init_result.stderr}")
            await update.message.reply_text(f"Failed to initialize CLAUDE.md:\n{init_result.stderr[:500]}")
            return False

        await update.message.reply_text("CLAUDE.md initialized successfully! Committing and pushing to main branch...")
        logger.info(f"Successfully initialized CLAUDE.md in {project_workdir}")

        # Commit and push CLAUDE.md to main
        try:
            # Add CLAUDE.md to git
            add_result = subprocess.run(
                ["git", "add", "CLAUDE.md"],
                cwd=project_workdir,
                capture_output=True,
                text=True,
                timeout=60
            )

            if add_result.returncode != 0:
                logger.error(f"git add failed: {add_result.stderr}")
                await update.message.reply_text(f"Warning: Could not add CLAUDE.md to git:\n{add_result.stderr[:500]}")
                return True  # Still return True as initialization succeeded

            # Commit CLAUDE.md
            commit_message = """Add CLAUDE.md documentation for codebase architecture

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"""

            commit_result = subprocess.run(
                ["git", "commit", "-m", commit_message],
                cwd=project_workdir,
                capture_output=True,
                text=True,
                timeout=60
            )

            if commit_result.returncode != 0:
                logger.error(f"git commit failed: {commit_result.stderr}")
                await update.message.reply_text(f"Warning: Could not commit CLAUDE.md:\n{commit_result.stderr[:500]}")
                return True  # Still return True as initialization succeeded

            # Push to main branch
            push_result = subprocess.run(
                ["git", "push", "origin", "main"],
                cwd=project_workdir,
                capture_output=True,
                text=True,
                timeout=300
            )

            if push_result.returncode != 0:
                logger.error(f"git push failed: {push_result.stderr}")
                await update.message.reply_text(f"Warning: Could not push CLAUDE.md to main:\n{push_result.stderr[:500]}")
                return True  # Still return True as initialization succeeded

            await update.message.reply_text("CLAUDE.md committed and pushed to main successfully!")
            logger.info(f"Successfully committed and pushed CLAUDE.md to main in {project_workdir}")

        except subprocess.TimeoutExpired:
            await update.message.reply_text("Warning: Git operation timed out")
            return True  # Still return True as initialization succeeded
        except Exception as e:
            logger.error(f"Error committing/pushing CLAUDE.md: {e}")
            await update.message.reply_text(f"Warning: Error with git operations: {str(e)}")
            return True  # Still return True as initialization succeeded

        return True

    except subprocess.TimeoutExpired:
        await update.message.reply_text("Claude initialization timed out after 30 minutes")
        return False
    except Exception as e:
        logger.error(f"Error initializing CLAUDE.md: {e}")
        await update.message.reply_text(f"Error initializing CLAUDE.md: {str(e)}")
        return False

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle all messages and reply if bot is mentioned."""
    if not is_authorized(update):
        logger.info("Unauthorized user attempted to use bot")
        authorized_list = ", ".join(AUTHORIZED_USERS)
        await update.message.reply_text(f"I only respond to {authorized_list}")
        return

    message = update.message
    if not message or not message.text:
        logger.info("Received update with no text")
        return

    bot_username = f"@{context.bot.username}"

    logger.info(f"Chat type: {message.chat.type}")
    logger.info(f"Message from: {message.from_user.username}")
    logger.info(f"Message text: {message.text}")
    logger.info(f"Bot username: {bot_username}")

    is_mentioned = False

    if message.entities:
        for entity in message.entities:
            if entity.type == "mention":
                mentioned_text = message.text[entity.offset:entity.offset + entity.length]
                logger.info(f"Found mention: {mentioned_text}")
                if mentioned_text == bot_username:
                    is_mentioned = True
                    break
            elif entity.type == "text_mention":
                if entity.user and entity.user.id == context.bot.id:
                    is_mentioned = True
                    break

    if not is_mentioned and bot_username.lower() in message.text.lower():
        is_mentioned = True
        logger.info("Found bot username in text (case insensitive)")

    if is_mentioned:
        text_without_mention = message.text.replace(bot_username, "").strip()
        logger.info(f"Bot was mentioned! Replying...")

        if text_without_mention:
            await message.reply_text(text_without_mention)
        else:
            await message.reply_text("Hello")

        logger.info(f"Reply sent!")
    else:
        logger.info("Bot was not mentioned in this message")

async def cmd_ask(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /ask command. Format: /ask project-name query"""
    if not is_authorized(update):
        logger.info("Unauthorized user attempted to use /ask command")
        authorized_list = ", ".join(AUTHORIZED_USERS)
        await update.message.reply_text(f"I only respond to {authorized_list}")
        return

    logger.info("Received /ask command")

    if not context.args or len(context.args) < 2:
        await update.message.reply_text("Usage: /ask project-name query")
        return

    project_name = context.args[0]
    user_text = " ".join(context.args[1:])

    project = None
    for p in PROJECTS:
        if p['project_name'] == project_name:
            project = p
            break

    if not project:
        available_projects = ", ".join([p['project_name'] for p in PROJECTS])
        await update.message.reply_text(f"Project '{project_name}' not found. Available projects: {available_projects}")
        return

    project_repo = project['project_repo']
    project_workdir = project['project_workdir']

    if not await clone_repository_if_needed(update, project_repo, project_workdir):
        return

    if not await initialize_claude_md_if_needed(update, project_workdir):
        return

    await update.message.reply_text(f"Processing for project: {project_name}...")

    request_uuid = str(uuid.uuid4())
    output_file = f"/tmp/output_{request_uuid}.txt"

    try:
        prompt = f"""Project: {project_name}
Repository: {project_repo}
Working Directory: {project_workdir}

Query: {user_text}

Write the output in {output_file}"""

        cmd = ["claude", "--dangerously-skip-permissions", "--verbose", "--system-prompt", ASK_RULES, prompt]
        logger.info(f"Running command for project {project_name} with UUID {request_uuid}")

        result, duration_minutes = await run_claude_command(cmd, project_workdir, request_uuid)
        await process_output_file(update, output_file, duration_minutes)

    except subprocess.TimeoutExpired:
        await update.message.reply_text("Command timed out after 30 minutes")
        cleanup_output_file(output_file)
    except Exception as e:
        logger.error(f"Error running command: {e}")
        await update.message.reply_text(f"Error: {str(e)}")
        cleanup_output_file(output_file)

async def cmd_feat(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /feat command. Format: /feat project-name prompt"""
    if not is_authorized(update):
        logger.info("Unauthorized user attempted to use /feat command")
        authorized_list = ", ".join(AUTHORIZED_USERS)
        await update.message.reply_text(f"I only respond to {authorized_list}")
        return

    logger.info("Received /feat command")

    if not context.args or len(context.args) < 2:
        await update.message.reply_text("Usage: /feat project-name prompt")
        return

    project_name = context.args[0]
    user_prompt = " ".join(context.args[1:])

    project = None
    for p in PROJECTS:
        if p['project_name'] == project_name:
            project = p
            break

    if not project:
        available_projects = ", ".join([p['project_name'] for p in PROJECTS])
        await update.message.reply_text(f"Project '{project_name}' not found. Available projects: {available_projects}")
        return

    project_repo = project['project_repo']
    project_workdir = project['project_workdir']

    if not await clone_repository_if_needed(update, project_repo, project_workdir):
        return

    if not await initialize_claude_md_if_needed(update, project_workdir):
        return

    if not await refresh_to_main_branch(update, project_workdir):
        return

    await update.message.reply_text(f"Processing for project: {project_name}...")

    request_uuid = str(uuid.uuid4())
    output_file = f"/tmp/output_{request_uuid}.txt"

    try:
        prompt = f"""Project: {project_name}
Repository: {project_repo}
Working Directory: {project_workdir}

Task: {user_prompt}

Write the output in {output_file}"""

        cmd = ["claude", "--dangerously-skip-permissions", "--verbose", "--system-prompt", FEAT_RULES, prompt]
        logger.info(f"Running command for project {project_name} with UUID {request_uuid}")

        result, duration_minutes = await run_claude_command(cmd, project_workdir, request_uuid)
        await process_output_file(update, output_file, duration_minutes)

    except subprocess.TimeoutExpired:
        await update.message.reply_text("Command timed out after 30 minutes")
        cleanup_output_file(output_file)
    except Exception as e:
        logger.error(f"Error running command: {e}")
        await update.message.reply_text(f"Error: {str(e)}")
        cleanup_output_file(output_file)

async def cmd_fix(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /fix command. Format: /fix project-name prompt"""
    if not is_authorized(update):
        logger.info("Unauthorized user attempted to use /fix command")
        authorized_list = ", ".join(AUTHORIZED_USERS)
        await update.message.reply_text(f"I only respond to {authorized_list}")
        return

    logger.info("Received /fix command")

    if not context.args or len(context.args) < 2:
        await update.message.reply_text("Usage: /fix project-name prompt")
        return

    project_name = context.args[0]
    user_prompt = " ".join(context.args[1:])

    project = None
    for p in PROJECTS:
        if p['project_name'] == project_name:
            project = p
            break

    if not project:
        available_projects = ", ".join([p['project_name'] for p in PROJECTS])
        await update.message.reply_text(f"Project '{project_name}' not found. Available projects: {available_projects}")
        return

    project_repo = project['project_repo']
    project_workdir = project['project_workdir']

    if not await clone_repository_if_needed(update, project_repo, project_workdir):
        return

    if not await initialize_claude_md_if_needed(update, project_workdir):
        return

    await update.message.reply_text(f"Processing for project: {project_name}...")

    if not await refresh_to_main_branch(update, project_workdir):
        return

    request_uuid = str(uuid.uuid4())
    output_file = f"/tmp/output_{request_uuid}.txt"

    try:
        prompt = f"""Project: {project_name}
Repository: {project_repo}
Working Directory: {project_workdir}

Task: {user_prompt}

Write the output in {output_file}"""

        cmd = ["claude", "--dangerously-skip-permissions", "--verbose", "--system-prompt", FIX_RULES, prompt]
        logger.info(f"Running command for project {project_name} with UUID {request_uuid}")

        result, duration_minutes = await run_claude_command(cmd, project_workdir, request_uuid)
        await process_output_file(update, output_file, duration_minutes)

    except subprocess.TimeoutExpired:
        await update.message.reply_text("Command timed out after 30 minutes")
        cleanup_output_file(output_file)
    except Exception as e:
        logger.error(f"Error running command: {e}")
        await update.message.reply_text(f"Error: {str(e)}")
        cleanup_output_file(output_file)

async def cmd_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /feedback command. Format: /feedback project-name prompt"""
    if not is_authorized(update):
        logger.info("Unauthorized user attempted to use /feedback command")
        authorized_list = ", ".join(AUTHORIZED_USERS)
        await update.message.reply_text(f"I only respond to {authorized_list}")
        return

    logger.info("Received /feedback command")

    if not context.args or len(context.args) < 2:
        await update.message.reply_text("Usage: /feedback project-name prompt")
        return

    project_name = context.args[0]
    user_prompt = " ".join(context.args[1:])

    project = None
    for p in PROJECTS:
        if p['project_name'] == project_name:
            project = p
            break

    if not project:
        available_projects = ", ".join([p['project_name'] for p in PROJECTS])
        await update.message.reply_text(f"Project '{project_name}' not found. Available projects: {available_projects}")
        return

    project_repo = project['project_repo']
    project_workdir = project['project_workdir']

    if not await clone_repository_if_needed(update, project_repo, project_workdir):
        return

    if not await initialize_claude_md_if_needed(update, project_workdir):
        return

    await update.message.reply_text(f"Processing for project: {project_name}...")

    request_uuid = str(uuid.uuid4())
    output_file = f"/tmp/output_{request_uuid}.txt"

    try:
        prompt = f"""Project: {project_name}
Repository: {project_repo}
Working Directory: {project_workdir}

Task: {user_prompt}

Write the output in {output_file}"""

        cmd = ["claude", "--dangerously-skip-permissions", "--verbose", "--system-prompt", FEEDBACK_RULES, prompt]
        logger.info(f"Running command for project {project_name} with UUID {request_uuid}")

        result, duration_minutes = await run_claude_command(cmd, project_workdir, request_uuid)
        await process_output_file(update, output_file, duration_minutes)

    except subprocess.TimeoutExpired:
        await update.message.reply_text("Command timed out after 30 minutes")
        cleanup_output_file(output_file)
    except Exception as e:
        logger.error(f"Error running command: {e}")
        await update.message.reply_text(f"Error: {str(e)}")
        cleanup_output_file(output_file)

async def cmd_init(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /init command. Format: /init project-name"""
    if not is_authorized(update):
        logger.info("Unauthorized user attempted to use /init command")
        authorized_list = ", ".join(AUTHORIZED_USERS)
        await update.message.reply_text(f"I only respond to {authorized_list}")
        return

    logger.info("Received /init command")

    if not context.args or len(context.args) < 1:
        await update.message.reply_text("Usage: /init project-name")
        return

    project_name = context.args[0]

    project = None
    for p in PROJECTS:
        if p['project_name'] == project_name:
            project = p
            break

    if not project:
        available_projects = ", ".join([p['project_name'] for p in PROJECTS])
        await update.message.reply_text(f"Project '{project_name}' not found. Available projects: {available_projects}")
        return

    project_repo = project['project_repo']
    project_workdir = project['project_workdir']

    if not await clone_repository_if_needed(update, project_repo, project_workdir):
        return

    if not await initialize_claude_md_if_needed(update, project_workdir):
        await update.message.reply_text(f"Failed to initialize CLAUDE.md for project: {project_name}")
        return

    await update.message.reply_text(f"Successfully initialized CLAUDE.md for project: {project_name}")

async def cmd_cost(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /cost command. Displays Claude usage costs via claude-monitor."""
    if not is_authorized(update):
        logger.info("Unauthorized user attempted to use /cost command")
        authorized_list = ", ".join(AUTHORIZED_USERS)
        await update.message.reply_text(f"I only respond to {authorized_list}")
        return

    logger.info("Received /cost command")

    await update.message.reply_text("Fetching Claude usage costs...")

    log_file = "claude-monitor.log"

    try:
        # Run the claude-monitor command
        cmd = f"rm {log_file} || true && claude-monitor --view daily >{log_file} 2>&1 < /dev/null & sleep 3 && pkill -f \"claude-monitor --view\""

        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            timeout=30
        )

        logger.info(f"claude-monitor command completed with return code: {result.returncode}")

        prompt = f"""
Please edit the {log_file}, just take the Summary, remove everything else. Also remove the ASCII lines and make it chat message friendly.
"""

        cmd = ["claude", "--dangerously-skip-permissions", "--verbose", "--system-prompt", ASK_RULES, prompt]
        project_workdir = os.path.dirname(__file__)
        request_uuid = str(uuid.uuid4())
        result, duration_minutes = await run_claude_command(cmd, project_workdir, request_uuid)

        # Read the log file instead of stdout
        if os.path.exists(log_file):
            with open(log_file, 'r') as f:
                log_content = f.read()

            if log_content:
                if len(log_content) > 4000:
                    await update.message.reply_text(log_content[:4000] + "\n\n[Output truncated...]")
                else:
                    await update.message.reply_text(log_content)
            else:
                await update.message.reply_text("No cost data available in log file.")
        else:
            await update.message.reply_text("claude-monitor.log file not found. Make sure claude-monitor is installed.")

    except subprocess.TimeoutExpired:
        await update.message.reply_text("Command timed out after 30 seconds")
    except Exception as e:
        logger.error(f"Error running claude-monitor command: {e}")
        await update.message.reply_text(f"Error fetching cost data: {str(e)}")

async def send_startup_messages(application: Application) -> None:
    """Send startup notification to all authorized groups."""
    logger.info("Sending startup notifications to authorized groups...")

    for group_id in AUTHORIZED_GROUPS:
        try:
            await application.bot.send_message(
                chat_id=group_id,
                text="Bot is now online and ready to receive commands."
            )
            logger.info(f"Sent startup message to group {group_id}")
        except Exception as e:
            logger.error(f"Failed to send startup message to group {group_id}: {e}")

def main():
    parser = argparse.ArgumentParser(description='Telegram bot that replies when mentioned')
    parser.add_argument('--api-token', required=True, help='Telegram Bot API token')
    args = parser.parse_args()

    load_config()

    application = Application.builder().token(args.api_token).build()

    application.add_handler(CommandHandler("ask", cmd_ask))
    application.add_handler(CommandHandler("feat", cmd_feat))
    application.add_handler(CommandHandler("fix", cmd_fix))
    application.add_handler(CommandHandler("feedback", cmd_feedback))
    application.add_handler(CommandHandler("init", cmd_init))
    application.add_handler(CommandHandler("cost", cmd_cost))

    application.add_handler(MessageHandler(
        filters.ALL,
        handle_message
    ))

    # Set up post-init hook to send startup messages
    async def post_init(app: Application) -> None:
        await send_startup_messages(app)

    application.post_init = post_init

    logger.info("Bot is starting...")
    logger.info("Listening for messages and commands...")
    application.run_polling(allowed_updates=Update.ALL_TYPES, drop_pending_updates=True)

if __name__ == '__main__':
    main()
